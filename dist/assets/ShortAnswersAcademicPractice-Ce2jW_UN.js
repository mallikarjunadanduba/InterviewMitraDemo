import{U as G,r as t,j as s,B as m,P as _,T as w,D as J,G as n,F as c,h as l,S as d,d as V,az as r}from"./index-So8Y0uMi.js";import{d as X}from"./PlayArrow-fFRiTYJQ.js";import{M as u}from"./MenuItem-CSdFaWhF.js";const i={sections:{dataStructures:{name:"Data Structures",questions:[{shortAnswerId:1,question:"Explain the difference between a stack and a queue. Provide examples of when you would use each.",expectedAnswer:"Stack follows LIFO (Last In, First Out) principle - elements are added and removed from the same end. Use cases: function call management, expression evaluation, undo operations. Queue follows FIFO (First In, First Out) principle - elements are added at rear and removed from front. Use cases: task scheduling, breadth-first search, handling requests in order.",wordLimit:120},{shortAnswerId:2,question:"Describe the time complexity of different sorting algorithms and when you would choose each one.",expectedAnswer:"Bubble Sort: O(n²) - simple but inefficient, use for small datasets. Selection Sort: O(n²) - good for minimizing swaps. Insertion Sort: O(n²) average, O(n) best case - efficient for small or nearly sorted data. Merge Sort: O(n log n) - stable, consistent performance, good for large datasets. Quick Sort: O(n log n) average, O(n²) worst case - fastest in practice, in-place sorting. Heap Sort: O(n log n) - guaranteed performance, good for embedded systems.",wordLimit:150},{shortAnswerId:3,question:"What is a hash table and how does it achieve O(1) average case lookup time?",expectedAnswer:"A hash table is a data structure that uses a hash function to map keys to array indices. It achieves O(1) average case lookup by: 1) Using a hash function to compute array index from key, 2) Storing key-value pairs at computed indices, 3) Handling collisions through chaining (linked lists) or open addressing. The hash function distributes keys uniformly across buckets, minimizing collisions and maintaining constant average access time.",wordLimit:100},{shortAnswerId:4,question:"Explain the concept of binary trees and their advantages over other data structures.",expectedAnswer:"A binary tree is a hierarchical data structure where each node has at most two children (left and right). Advantages: 1) Efficient searching in BSTs (O(log n)), 2) Hierarchical representation of data relationships, 3) Memory efficient compared to arrays for sparse data, 4) Supports various traversal methods (inorder, preorder, postorder), 5) Foundation for advanced structures like AVL trees and heaps.",wordLimit:130},{shortAnswerId:5,question:"What are the different types of linked lists and their use cases?",expectedAnswer:"Singly Linked List: Each node points to next node only. Use cases: implementing stacks, simple lists. Doubly Linked List: Each node points to both next and previous nodes. Use cases: implementing deques, browser history, undo/redo functionality. Circular Linked List: Last node points back to first. Use cases: round-robin scheduling, implementing circular buffers. Skip List: Multi-level linked list with express lanes. Use cases: fast searching with O(log n) complexity.",wordLimit:120}]},algorithms:{name:"Algorithms",questions:[{shortAnswerId:6,question:"Explain the divide and conquer approach with a specific algorithm example.",expectedAnswer:"Divide and conquer breaks problems into smaller subproblems, solves them recursively, and combines solutions. Example: Merge Sort. Steps: 1) Divide: Split array into two halves, 2) Conquer: Recursively sort both halves, 3) Combine: Merge sorted halves. Time complexity: O(n log n). Other examples: Quick Sort, Binary Search, Fast Fourier Transform. The approach reduces problem complexity and enables parallel processing.",wordLimit:130},{shortAnswerId:7,question:"Describe the difference between dynamic programming and greedy algorithms.",expectedAnswer:"Dynamic Programming: Solves problems by breaking into overlapping subproblems, storing solutions to avoid recomputation. Uses optimal substructure and overlapping subproblems. Example: Fibonacci sequence, knapsack problem. Greedy Algorithms: Make locally optimal choices at each step, hoping for global optimum. No backtracking, no storing previous solutions. Example: Huffman coding, activity selection. DP guarantees optimal solution, greedy may not.",wordLimit:120},{shortAnswerId:8,question:"How does the binary search algorithm work and what are its prerequisites?",expectedAnswer:"Binary search finds target in sorted array by repeatedly dividing search space in half. Steps: 1) Compare target with middle element, 2) If equal, return index, 3) If target < middle, search left half, 4) If target > middle, search right half, 5) Repeat until found or search space exhausted. Prerequisites: Array must be sorted. Time complexity: O(log n). Space complexity: O(1) iterative, O(log n) recursive. Works on any sorted sequence, not just arrays.",wordLimit:110},{shortAnswerId:9,question:"Explain the concept of Big O notation and its importance in algorithm analysis.",expectedAnswer:"Big O notation describes the upper bound of an algorithm's time or space complexity as input size approaches infinity. It focuses on worst-case scenario and ignores constants and lower-order terms. Common complexities: O(1) constant, O(log n) logarithmic, O(n) linear, O(n log n) linearithmic, O(n²) quadratic, O(2^n) exponential. Importance: 1) Compares algorithm efficiency, 2) Predicts performance on large inputs, 3) Helps choose appropriate algorithm for problem constraints, 4) Essential for scalable system design.",wordLimit:140},{shortAnswerId:10,question:"What is recursion and when should you use it versus iteration?",expectedAnswer:"Recursion is a programming technique where a function calls itself to solve smaller instances of the same problem. Use recursion when: 1) Problem has recursive structure (tree traversal, factorial), 2) Solution is more intuitive, 3) Working with recursive data structures. Use iteration when: 1) Performance is critical (no function call overhead), 2) Stack overflow risk with deep recursion, 3) Simple loops are clearer. Recursion requires base case to prevent infinite loops and consumes stack memory.",wordLimit:130}]},databases:{name:"Database Systems",questions:[{shortAnswerId:11,question:"Explain ACID properties in database transactions with examples.",expectedAnswer:"ACID ensures reliable database transactions. Atomicity: Transaction is all-or-nothing. Example: Bank transfer - both debit and credit must succeed or both fail. Consistency: Database remains in valid state before and after transaction. Example: Account balance cannot be negative. Isolation: Concurrent transactions don't interfere. Example: Two users updating same record see consistent data. Durability: Committed changes persist despite system failures. Example: Data survives power outages or crashes.",wordLimit:140},{shortAnswerId:12,question:"What is normalization and why is it important in database design?",expectedAnswer:"Normalization is the process of organizing data to reduce redundancy and improve data integrity. Benefits: 1) Eliminates data duplication, 2) Reduces storage space, 3) Prevents update anomalies, 4) Maintains data consistency. Normal forms: 1NF (atomic values), 2NF (no partial dependencies), 3NF (no transitive dependencies). Example: Instead of storing customer address in every order, store it once in customer table and reference it. Trade-off: More joins required for queries.",wordLimit:120},{shortAnswerId:13,question:"Describe the difference between SQL and NoSQL databases.",expectedAnswer:"SQL databases are relational, use structured schema, support ACID transactions, and use SQL for queries. Examples: MySQL, PostgreSQL. NoSQL databases are non-relational, use flexible schema, prioritize scalability and performance, and use various query languages. Types: Document (MongoDB), Key-value (Redis), Column-family (Cassandra), Graph (Neo4j). Choose SQL for complex queries and ACID compliance. Choose NoSQL for scalability, flexibility, and big data applications.",wordLimit:100},{shortAnswerId:14,question:"What are database indexes and how do they improve query performance?",expectedAnswer:"Indexes are data structures that improve query speed by providing fast access paths to data. Types: B-tree (most common), Hash, Bitmap. Benefits: 1) Faster data retrieval, 2) Efficient sorting and grouping, 3) Unique constraint enforcement. Trade-offs: 1) Additional storage space, 2) Slower insert/update/delete operations, 3) Maintenance overhead. Best practices: Index frequently queried columns, avoid over-indexing, monitor index usage. Example: Index on customer_id speeds up WHERE customer_id = 123 queries.",wordLimit:130},{shortAnswerId:15,question:"Explain database relationships and their types.",expectedAnswer:"Database relationships define how tables connect. Types: 1) One-to-One: Each record in Table A relates to one record in Table B. Example: User and UserProfile. 2) One-to-Many: One record in Table A relates to many records in Table B. Example: Customer and Orders. 3) Many-to-Many: Records in both tables can relate to multiple records in the other. Requires junction table. Example: Students and Courses. Relationships maintain referential integrity and enable complex queries across related data.",wordLimit:120}]},operatingSystems:{name:"Operating Systems",questions:[{shortAnswerId:16,question:"Explain the concept of virtual memory and its benefits.",expectedAnswer:"Virtual memory is a memory management technique that uses disk storage to extend available RAM. Benefits: 1) Allows programs larger than physical RAM, 2) Enables multitasking by isolating processes, 3) Provides memory protection between processes, 4) Allows efficient memory sharing. How it works: OS maps virtual addresses to physical addresses, swaps pages between RAM and disk as needed. Page faults occur when accessing unmapped memory, triggering page loading from disk.",wordLimit:110},{shortAnswerId:17,question:"What is a deadlock and how can it be prevented?",expectedAnswer:"Deadlock occurs when two or more processes wait indefinitely for resources held by each other. Four conditions: mutual exclusion, hold and wait, no preemption, circular wait. Prevention strategies: 1) Avoid one of the four conditions, 2) Resource ordering (acquire resources in fixed order), 3) Timeout mechanisms, 4) Deadlock detection and recovery. Example: Process A holds Resource 1 and needs Resource 2, Process B holds Resource 2 and needs Resource 1. Solution: Acquire resources in same order (e.g., always acquire Resource 1 before Resource 2).",wordLimit:120},{shortAnswerId:18,question:"Describe the difference between process and thread.",expectedAnswer:"Process is an independent program execution unit with its own memory space, resources, and execution context. Thread is a lightweight unit within a process that shares memory space and resources. Key differences: 1) Memory: Processes have separate memory spaces, threads share memory, 2) Creation: Processes are expensive to create, threads are lightweight, 3) Communication: Processes use IPC mechanisms, threads share variables directly, 4) Fault isolation: Process crash doesn't affect others, thread crash affects entire process. Use processes for isolation, threads for parallelism within a program.",wordLimit:100},{shortAnswerId:19,question:"What are the different CPU scheduling algorithms and their characteristics?",expectedAnswer:"CPU scheduling algorithms determine which process runs next. Types: 1) FCFS (First Come First Served): Simple but can cause convoy effect, 2) SJF (Shortest Job First): Optimal for minimizing average waiting time but requires job length knowledge, 3) Round Robin: Fair, time-sliced, good for interactive systems, 4) Priority Scheduling: Higher priority processes run first, can cause starvation, 5) Multilevel Queue: Different queues for different process types. Each algorithm balances fairness, efficiency, and responsiveness based on system requirements.",wordLimit:130},{shortAnswerId:20,question:"Explain the concept of file systems and their organization.",expectedAnswer:"File systems organize and manage data storage on disk. Components: 1) Directory structure (hierarchical organization), 2) File allocation methods (contiguous, linked, indexed), 3) Free space management (bitmaps, linked lists), 4) Access control and permissions. Types: FAT (simple, limited), NTFS (Windows, advanced features), ext4 (Linux, journaling), HFS+ (macOS). File systems provide abstraction over physical storage, enabling file operations like create, read, write, delete, and directory navigation.",wordLimit:120}]}},universities:[{value:"bangalore-university",label:"Bangalore University"},{value:"visvesvaraya-technological-university",label:"Visvesvaraya Technological University"},{value:"karnataka-state-open-university",label:"Karnataka State Open University"},{value:"rajiv-gandhi-university",label:"Rajiv Gandhi University of Health Sciences"},{value:"karnataka-state-law-university",label:"Karnataka State Law University"},{value:"karnataka-state-rural-development",label:"Karnataka State Rural Development and Panchayat Raj University"},{value:"other",label:"Other University"}],educationTypes:[{value:"bsc-cs",label:"BSC – CS"},{value:"bca",label:"BCA"},{value:"be-cs-is",label:"BE (CS & IS)"},{value:"msc-cs",label:"M.SC (CS)"},{value:"mca",label:"MCA"},{value:"mtech",label:"M. Tech"}],expertiseLevels:[{expertiseLevelId:1,levelName:"Beginner"},{expertiseLevelId:2,levelName:"Intermediate"},{expertiseLevelId:3,levelName:"Advanced"},{expertiseLevelId:4,levelName:"Expert"}],experienceLevels:[{experienceId:1,experienceName:"0-1 years"},{experienceId:2,experienceName:"1-3 years"},{experienceId:3,experienceName:"3-5 years"},{experienceId:4,experienceName:"5+ years"}]},se=()=>{const k=G(),[h,q]=t.useState(!0),[S,E]=t.useState([]),[p,j]=t.useState(""),[g,C]=t.useState(""),[f,O]=t.useState(""),[T,P]=t.useState([]),[F,R]=t.useState([]),[v,D]=t.useState(""),[x,B]=t.useState(""),[A,I]=t.useState(!1),y=t.useRef(Date.now()),M=t.useRef(null),N="Short Answers Academic Assessment",U="PRACTICE",Q=30;""+JSON.parse(sessionStorage.getItem("user")).accessToken;const W=i.universities,z=i.educationTypes;t.useEffect(()=>{const e=new BroadcastChannel("exam_channel");return M.current=e,e.postMessage({type:"check",tabId:y.current}),e.onmessage=a=>{const{type:o,tabId:L}=a.data;o==="check"?e.postMessage({type:"active",tabId:y.current}):o==="active"&&L!==y.current&&q(!1)},()=>{e.close()}},[]),t.useEffect(()=>{const e=Object.keys(i.sections).map((a,o)=>({topicId:o+1,topicName:i.sections[a].name}));E(e),P(i.expertiseLevels),R(i.experienceLevels)},[]);const H=async()=>{if(!h){alert("Another tab is open. Close it before starting.");return}if(!p){r.fire("Incomplete","Please select a topic","warning");return}if(!g){r.fire("Incomplete","Please select university","warning");return}if(!f){r.fire("Incomplete","Please select education type","warning");return}if(!v){r.fire("Incomplete","Please select expertise level","warning");return}if(!x){r.fire("Incomplete","Please select experience level","warning");return}const e=S.find(a=>a.topicId===p);if(!e){r.fire("Error","Invalid topic selected","error");return}I(!0);try{const o=Object.keys(i.sections)[p-1],b=i.sections[o].questions.slice(0,10);await new Promise(K=>setTimeout(K,1e3)),b&&b.length>0?k("/jobs/short-answers-exam",{state:{shortAnswerData:b,selectedTopic:e,selectedMode:U,expertiseLevelId:v,experienceId:x,university:g,education:f}}):r.fire("No Questions","No Short Answer questions available for selected filters.","info")}catch(a){console.error("Error fetching short answer data:",a),r.fire("Error","Failed to load questions. Please try again.","error")}finally{I(!1)}};return s.jsx(m,{sx:{p:3},children:s.jsxs(_,{elevation:3,sx:{p:4,borderRadius:2},children:[s.jsx(w,{variant:"h4",gutterBottom:!0,align:"center",color:"primary",children:N}),s.jsx(J,{sx:{my:3}}),s.jsxs(n,{container:!0,spacing:3,children:[s.jsx(n,{item:!0,xs:12,md:6,children:s.jsxs(c,{fullWidth:!0,children:[s.jsx(l,{children:"Select Topic"}),s.jsx(d,{value:p,onChange:e=>j(e.target.value),label:"Select Topic",children:S.map(e=>s.jsx(u,{value:e.topicId,children:e.topicName},e.topicId))})]})}),s.jsx(n,{item:!0,xs:12,md:6,children:s.jsxs(c,{fullWidth:!0,children:[s.jsx(l,{children:"University"}),s.jsx(d,{value:g,onChange:e=>C(e.target.value),label:"University",children:W.map(e=>s.jsx(u,{value:e.value,children:e.label},e.value))})]})}),s.jsx(n,{item:!0,xs:12,md:6,children:s.jsxs(c,{fullWidth:!0,children:[s.jsx(l,{children:"Education Type"}),s.jsx(d,{value:f,onChange:e=>O(e.target.value),label:"Education Type",children:z.map(e=>s.jsx(u,{value:e.value,children:e.label},e.value))})]})}),s.jsx(n,{item:!0,xs:12,md:6,children:s.jsxs(c,{fullWidth:!0,children:[s.jsx(l,{children:"Expertise Level"}),s.jsx(d,{value:v,onChange:e=>D(e.target.value),label:"Expertise Level",children:T.map(e=>s.jsx(u,{value:e.expertiseLevelId,children:e.levelName},e.expertiseLevelId))})]})}),s.jsx(n,{item:!0,xs:12,md:6,children:s.jsxs(c,{fullWidth:!0,children:[s.jsx(l,{children:"Experience Level"}),s.jsx(d,{value:x,onChange:e=>B(e.target.value),label:"Experience Level",children:F.map(e=>s.jsx(u,{value:e.experienceId,children:e.experienceName},e.experienceId))})]})}),s.jsx(n,{item:!0,xs:12,md:6,children:s.jsx(m,{sx:{display:"flex",alignItems:"center",height:"100%"},children:s.jsxs(w,{variant:"h6",color:"text.secondary",children:["Duration: ",Q," minutes"]})})})]}),s.jsx(m,{sx:{textAlign:"center",mt:4},children:s.jsx(V,{variant:"contained",size:"large",startIcon:s.jsx(X,{}),onClick:H,disabled:A||!h,sx:{px:4,py:1.5,fontSize:"1.1rem",borderRadius:2},children:A?"Loading...":"Start Short Answers Assessment"})}),!h&&s.jsx(m,{sx:{textAlign:"center",mt:2},children:s.jsx(w,{color:"error",children:"Another tab is open. Please close it before starting the assessment."})})]})})};export{se as default};
